<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Real-Time Spreadsheet</title>
  <link data-trunk rel="rust" data-target-name="lab1" />
  <style>
    :root {
      --bg-color: #f9f9f9;
      --text-color: #000;
      --border-color: #ccc;
      --input-bg: #fff;
      --input-text: #000;
    }

    body.dark-mode {
      --bg-color: #1e1e1e;
      --text-color: #f0f0f0;
      --border-color: #444;
      --input-bg: #2b2b2b;
      --input-text: #f0f0f0;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background 0.3s, color 0.3s;
    }

    #spreadsheet-container {
      margin: 20px;
      padding: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-color);
    }

    #formula-container {
      margin: 20px;
    }

    input[type="text"] {
      font-size: 16px;
      background-color: var(--input-bg);
      color: var(--input-text);
      border: 1px solid var(--border-color);
      padding: 4px 8px;
    }

    table {
      width: 100%;
    }

    th, td {
      padding: 5px;
      text-align: center;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px; width: 18px;
      left: 3px; bottom: 3px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #4CAF50;
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }
  </style>
</head>
<body>
<h1>Real-Time Spreadsheet</h1>
<div style="position: absolute; top: 20px; right: 20px;">
  <label class="switch">
    <input type="checkbox" id="theme-toggle">
    <span class="slider"></span>
  </label>
</div>

<div id="spreadsheet-container"></div>

<div id="formula-container">
  <label for="formula-input">Enter formula:</label>
  <input type="text" id="formula-input" placeholder="E.g., A1=42 or IMPORT(AAPL,10,A)" />
</div>

<div style="margin: 10px 20px;">
  <button id="undo-btn">Undo</button>
  <button id="redo-btn">Redo</button>
  <button id="download-csv-btn">Download CSV</button>
</div>

<div id="graph-container" style="margin: 20px;">
  <canvas id="graph-canvas" width="800" height="400"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="module">
  import init, { render_initial_spreadsheet, update_formula, undo, redo, export_csv }
    from "./lab1.js";

  async function runApp() {
    await init();

    const apiKey = "e666eaf09a49491fb9a9adefc743a7a3";
    const spreadsheetContainer = document.getElementById("spreadsheet-container");
    const formulaInput = document.getElementById("formula-input");

    spreadsheetContainer.innerHTML = render_initial_spreadsheet();

    formulaInput.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        const formula = formulaInput.value.trim();

        if (formula.startsWith("IMPORT(")) {
          const [, args] = formula.match(/^IMPORT\(([^)]+)\)/) || [];
          if (!args) return;

          const [symbol, daysStr, colChar] = args.split(",").map(s => s.trim());
          const days = parseInt(daysStr);
          const col = colChar.toUpperCase();

          const url = `https://api.twelvedata.com/time_series?symbol=${symbol}&interval=1day&outputsize=${days}&apikey=${apiKey}`;

          try {
            console.log("Trying to fetch:", url);
            const res = await fetch(url);
            const data = await res.json();
            const series = data.values;
            if (!series) return;

            for (let i = 0; i < days && i < series.length; i++) {
              const val = parseFloat(series[i].close);
              const cellFormula = `${col}${i + 1}=${Math.round(val)}`;
              const result = await update_formula(cellFormula);
              if (result !== "__IMPORT_EXTERNAL__") {
                spreadsheetContainer.innerHTML = result;
              }
            }

          } catch (err) {
            console.error("IMPORT failed:", err);
          }

          return;
        }

        if (formula.startsWith("GRAPH(")) {
          try {
            const graphPayload = await update_formula(formula);
            renderGraph(JSON.parse(graphPayload));
          } catch (err) {
            console.error("Graph rendering failed:", err);
          }
          return;
        }

        const updatedHTML = await update_formula(formula);
        if (updatedHTML !== "__IMPORT_EXTERNAL__") {
          spreadsheetContainer.innerHTML = updatedHTML;
        }
      }
    });

    document.getElementById("undo-btn").addEventListener("click", async () => {
      spreadsheetContainer.innerHTML = await undo();
    });

    document.getElementById("redo-btn").addEventListener("click", async () => {
      spreadsheetContainer.innerHTML = await redo();
    });

    document.getElementById("download-csv-btn").addEventListener("click", async () => {
      const csv = await export_csv();
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "spreadsheet.csv";
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById("theme-toggle").addEventListener("change", (e) => {
      document.body.classList.toggle("dark-mode", e.target.checked);
    });

    // Add global keyboard shortcuts
    document.addEventListener("keydown", async (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
        // Ctrl+Z or Command+Z for undo
        e.preventDefault();
        spreadsheetContainer.innerHTML = await undo();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === "y" || (e.key === "z" && e.shiftKey))) {
        // Ctrl+Y or Command+Y for redo, or Ctrl+Shift+Z or Command+Shift+Z
        e.preventDefault();
        spreadsheetContainer.innerHTML = await redo();
      } else if ((e.ctrlKey || e.metaKey) && e.key === "d") {
        // Ctrl+D or Command+D for toggling dark mode
        e.preventDefault();
        const themeToggle = document.getElementById("theme-toggle");
        themeToggle.checked = !themeToggle.checked;
        document.body.classList.toggle("dark-mode", themeToggle.checked);
      } else if ((e.ctrlKey || e.metaKey) && e.key === "s") {
        // Ctrl+S or Command+S for downloading CSV
        e.preventDefault();
        const csv = await export_csv();
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "spreadsheet.csv";
        a.click();
        URL.revokeObjectURL(url);
      } else if ((e.ctrlKey || e.metaKey) && e.key === "g") {
        // Ctrl+G or Command+G for downloading the graph
        e.preventDefault();
        const canvas = document.getElementById("graph-canvas");
        if (canvas) {
          const link = document.createElement("a");
          link.download = "graph.png";
          link.href = canvas.toDataURL("image/png");
          link.click();
        }
      }
    });
  }

  function renderGraph(data) {
    const graphContainer = document.getElementById("graph-container");
    graphContainer.innerHTML = '<canvas id="graph-canvas" width="800" height="400"></canvas>';
    const ctx = document.getElementById("graph-canvas").getContext("2d");

    const datasets = data.map((column, index) => ({
      label: `Column ${String.fromCharCode(65 + index)}`,
      data: column,
      borderColor: `hsl(${index * 60}, 70%, 50%)`,
      fill: false,
    }));

    new Chart(ctx, {
      type: "line",
      data: {
        labels: Array.from({ length: data[0].length }, (_, i) => i + 1),
        datasets,
      },
      options: {
        responsive: true,
        plugins: {
          legend: { position: "top" },
        },
      },
    });
  }

  window.handleCellBlur = async (event) => {
    const inputEl = event.target;
    const cellId = inputEl.getAttribute("data-cell");
    const newValue = inputEl.value.trim();
    const formula = `${cellId}=${newValue}`;
    try {
      const updatedHTML = await update_formula(formula);
      if (updatedHTML !== "__IMPORT_EXTERNAL__") {
        document.getElementById("spreadsheet-container").innerHTML = updatedHTML;
      }
    } catch (err) {
      console.error("Cell update failed:", err);
    }
  };

  window.handleCellKeyup = async (event) => {
    if (event.key === "Enter") {
      event.target.blur();
    }
  };

  runApp();
</script>
</body>
</html>
