<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Real-Time Spreadsheet</title>
  <!-- Tell Trunk to build your WASM library -->
  <link data-trunk rel="rust" data-target-name="lab1" />
  <style>
    :root {
      --bg-color: #f9f9f9;
      --text-color: #000;
      --border-color: #ccc;
      --input-bg: #fff;
      --input-text: #000;
    }
  
    body.dark-mode {
      --bg-color: #1e1e1e;
      --text-color: #f0f0f0;
      --border-color: #444;
      --input-bg: #2b2b2b;
      --input-text: #f0f0f0;
    }
  
    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background 0.3s, color 0.3s;
    }
  
    #spreadsheet-container {
      margin: 20px;
      padding: 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-color);
    }
  
    #formula-container {
      margin: 20px;
    }
  
    input[type="text"] {
      font-size: 16px;
      background-color: var(--input-bg);
      color: var(--input-text);
      border: 1px solid var(--border-color);
      padding: 4px 8px;
    }
  
    table {
      width: 100%;
    }
  
    th, td {
      padding: 5px;
      text-align: center;
    }
  </style>
  

</head>
<body>
<h1>Real-Time Spreadsheet</h1>

<!-- Container for the spreadsheet -->
<div id="spreadsheet-container"></div>

<!-- Formula input box -->
<div id="formula-container">
  <label for="formula-input">Enter formula:</label>
  <input type="text" id="formula-input" placeholder="E.g., A1=42 or A1=B2+5" />
</div>


<div id="graph-container" style="margin: 20px;">
  <canvas id="graph-canvas" width="800" height="400"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Import the WASM glue code using its full generated filename -->
<script type="module">
  // Change the following file name to match the one in your dist folder
  import init, { render_initial_spreadsheet, update_formula, undo, redo, export_csv }
    from "./lab1.js"; // Added `export_csv`

  async function runApp() {
    try {
      await init();

      const spreadsheetContainer = document.getElementById("spreadsheet-container");
      const formulaInput = document.getElementById("formula-input");

      // Render and display the initial spreadsheet
      let html = render_initial_spreadsheet();
      console.log("Initial spreadsheet HTML:", html);
      spreadsheetContainer.innerHTML = html;

      // Listen for keydown events in the formula input.
      formulaInput.addEventListener("keydown", async (e) => {
        if (e.key === "Enter") {
          const formula = formulaInput.value.trim();
          if (formula.startsWith("GRAPH(")) {
            try {
              const graphData = await update_formula(formula);
              renderGraph(JSON.parse(graphData));
            } catch (err) {
              console.error("Error generating graph:", err);
            }
          } else if (formula !== "") {
            const updatedHTML = await update_formula(formula);
            console.log(`Updated HTML for formula "${formula}":`, updatedHTML);
            spreadsheetContainer.innerHTML = updatedHTML;
          }
        }
      });
      document.getElementById("undo-btn").addEventListener("click", async () => {
        const html = await undo();
        document.getElementById("spreadsheet-container").innerHTML = html;
      });

      document.getElementById("redo-btn").addEventListener("click", async () => {
        const html = await redo();
        document.getElementById("spreadsheet-container").innerHTML = html;
      });

      // Add event listener for the "Download CSV" button
      document.getElementById("download-csv-btn").addEventListener("click", async () => {
        try {
          const csvData = await export_csv(); // Call the Rust function to get CSV data
          const blob = new Blob([csvData], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "spreadsheet.csv";
          a.click();
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("Error exporting CSV:", error);
        }
      });
    } catch (error) {
      console.error("Error initializing or updating the spreadsheet:", error);
    }
  }

  function renderGraph(data) {
    const graphContainer = document.getElementById("graph-container");
    graphContainer.innerHTML = '<canvas id="graph-canvas" width="800" height="400"></canvas>'; // Clear and recreate canvas
    const ctx = document.getElementById("graph-canvas").getContext("2d");

    const datasets = data.map((column, index) => ({
      label: `Column ${String.fromCharCode(65 + index)}`,
      data: column,
      borderColor: `hsl(${index * 60}, 70%, 50%)`,
      fill: false,
    }));

    new Chart(ctx, {
      type: "line",
      data: {
        labels: Array.from({ length: data[0].length }, (_, i) => i + 1),
        datasets,
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: "top",
          },
        },
      },
    });
  }

  // Event handler for when a cell loses focus
  window.handleCellBlur = async (event) => {
    const inputEl = event.target;
    const cellId = inputEl.getAttribute("data-cell"); // e.g. "A1"
    const newValue = inputEl.value.trim();

    // Form a formula like "A1=...". Optionally, you can further process newValue.
    const formula = `${cellId}=${newValue}`;
    console.log("Cell blur, updating with formula:", formula);
    try {
      const updatedHTML = await update_formula(formula);
      document.getElementById("spreadsheet-container").innerHTML = updatedHTML;
    } catch (err) {
      console.error("Error updating formula on cell blur:", err);
    }
  };

  // Event handler for keyup in a cell.
  // If Enter is pressed while editing a cell, process the update.
  window.handleCellKeyup = async (event) => {
    if (event.key === "Enter") {
      event.target.blur();  // Remove focus to trigger onblur handler
    }
  };

  runApp();

  // Keyboard shortcuts for Undo, Redo, Export CSV, and Toggle Dark Mode
document.addEventListener("keydown", async (e) => {
  const isCtrlOrCmd = e.ctrlKey || e.metaKey;

  if (isCtrlOrCmd && e.key === "z" && !e.shiftKey) {
    e.preventDefault();
    const html = await undo();
    document.getElementById("spreadsheet-container").innerHTML = html;
  }

  if ((isCtrlOrCmd && e.key === "y") || (isCtrlOrCmd && e.shiftKey && e.key === "Z")) {
    e.preventDefault();
    const html = await redo();
    document.getElementById("spreadsheet-container").innerHTML = html;
  }

  if (isCtrlOrCmd && e.key === "s") {
    e.preventDefault();
    try {
      const csvData = await export_csv();
      const blob = new Blob([csvData], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "spreadsheet.csv";
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error("Error exporting CSV:", error);
    }
  }

  if (isCtrlOrCmd && e.key.toLowerCase() === "d") {
    e.preventDefault();
    document.body.classList.toggle("dark-mode");
  }
});


document.getElementById("toggle-theme-btn").addEventListener("click", () => {
  document.body.classList.toggle("dark-mode");
});

</script>
</body>
</html>
